pragma solidity >=0.4.22 <0.6.0;

contract eCheque{
 //   string  public protoclName = "Electronic Cheque Contract";
  //  string  public symbol = "ECC";
// string  public standard = "eCheque Token v1.0";
    uint256 public totalSupply=1000000;

    struct customer{
        address bank;
        uint256 chequeNo;
        mapping(uint256 => cheque) cheques;
    }
    
    struct cheque{
        uint amount;
        address issuer;
        address bank;
        address owner;
        uint date;
        bytes32 signature;
    }
    
    mapping(address => uint256) public balanceOf;
    mapping(address => customer) public banks;
    
    constructor() public {
        balanceOf[msg.sender] = totalSupply;
    }

    function setBank(address _bank,uint256 _initialSuppl) public returns (bool success) {
       require(balanceOf[msg.sender]>_initialSuppl);
       balanceOf[msg.sender]-=_initialSuppl;
       balanceOf[_bank]=_initialSuppl;
       return true;
    }
    
    function setCustomer(address _customer) public returns (bool success) {
      banks[_customer].bank=msg.sender;
      banks[_customer].chequeNo=0;
      return true;
    }
    
    function setCheque(address _to,uint256 _cheque_amount) public returns (bool success) {
      
      assert(_cheque_amount>0);
      require(balanceOf[msg.sender]>_cheque_amount);
      banks[_to].chequeNo+=1;
      uint256 chequeNo = banks[_to].chequeNo;
      
      banks[_to].cheques[chequeNo].amount=_cheque_amount;
      banks[_to].cheques[chequeNo].owner=_to;
      banks[_to].cheques[chequeNo].issuer=_to;
      banks[_to].cheques[chequeNo].bank=msg.sender;
      
      balanceOf[msg.sender]-=_cheque_amount;
      balanceOf[_to]+=_cheque_amount;
     
      return true;
    }

    function signCheque(uint256 _chequeNo,uint _date,bytes32 _sig) public returns (bool success) {
     
      assert(_chequeNo>0);
      banks[msg.sender].cheques[_chequeNo].date=_date;
      banks[msg.sender].cheques[_chequeNo].signature=_sig;
      
      return true;
    }

    function transfer(address _to, address _issuer, uint256 _chequeNo) public returns (bool success) {
        assert(_chequeNo>0);
        
        address owner=getChequeOwner(_issuer,_chequeNo);
        address issuer =getChequeIssuer(_issuer,_chequeNo);
        uint amount = getChequeAmount(_issuer,_chequeNo);
       
        require(balanceOf[owner] >= amount);
        require(owner == msg.sender);
        
        balanceOf[owner] -= amount;
        balanceOf[_to] += amount;
        banks[issuer].cheques[_chequeNo].owner=_to;
        return true;
    }
    
    function deposit(address _issuer,uint256 _chequeNo) public returns (bool success) {
        assert(_chequeNo>0);
        require(now >getChequeDate(_issuer,_chequeNo));
        
        address owner=getChequeOwner(_issuer,_chequeNo);
        address bank =getChequeBank(_issuer,_chequeNo);
        uint amount = getChequeAmount(_issuer,_chequeNo);
        require(owner == msg.sender);
       
        balanceOf[owner] -= amount;
        balanceOf[bank] += amount;
        banks[bank].cheques[_chequeNo].owner=bank;
        
        return true;
    }
    
    function getChequeAmount(address _issuer,uint256 _chequeNo) public view returns (uint) {
        return banks[_issuer].cheques[_chequeNo].amount;
    }

    function getChequeDate(address _issuer,uint256 _chequeNo) public view returns (uint) {
        return banks[_issuer].cheques[_chequeNo].date;
    }
    
    function getChequeIssuer(address _issuer, uint256 _chequeNo) public view returns (address) {
        return banks[_issuer].cheques[_chequeNo].issuer;
    }
    
    function getChequeOwner(address _issuer,uint256 _chequeNo) public view returns (address) {
        return banks[_issuer].cheques[_chequeNo].owner;
    }
    
    function getChequeBank(address _issuer,uint256 _chequeNo) public view returns (address) {
        return banks[_issuer].cheques[_chequeNo].bank;
    }
    
    
}
